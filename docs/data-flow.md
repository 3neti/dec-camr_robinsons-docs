# üîÑ Data Flow

This document illustrates how data flows through the CAMR system, from meter readings in the field to reports generated by users. Understanding data flow is critical for troubleshooting, optimization, and system maintenance.

---

## üìã Overview

The CAMR system processes data through multiple stages:

1. **Collection** - Meters generate readings
2. **Transmission** - Gateways collect and upload data
3. **Storage** - Backend stores data in database
4. **Processing** - System aggregates and calculates metrics
5. **Presentation** - Users access data via reports and dashboards

---

## ‚ö° Primary Data Flow: Meter Reading to Database

### Complete Flow Diagram

```mermaid
flowchart TB
    subgraph Field["Field Layer (On-Site)"]
        M1[Energy Meter 1<br/>Modbus Slave]
        M2[Energy Meter 2]
        MN[Energy Meter N]
        RTU[RTU Gateway<br/>Python Script]
    end
    
    subgraph Transport["Data Transmission"]
        CSV[Load Profile CSV<br/>Timestamp, kWh, kW, etc.]
        HTTP[HTTP POST Request<br/>Multipart Form Data]
    end
    
    subgraph Backend["CAMR Backend"]
        API[Load Profile API<br/>/lp/receive_file.php]
        Controller[LoadProfileController]
        Validate[Data Validation<br/>MAC, Format, Values]
        Parse[CSV Parser]
    end
    
    subgraph Storage["Database"]
        UpdateMeter[Update meter_details<br/>last_log_update]
        StoreData[Insert meter_data<br/>Time-series records]
        UpdateGateway[Update meter_rtu<br/>last_log_update]
    end
    
    M1 -->|Modbus Read<br/>Every 15 min| RTU
    M2 -->|Modbus Read| RTU
    MN -->|Modbus Read| RTU
    
    RTU -->|Generate| CSV
    CSV -->|Upload| HTTP
    HTTP --> API
    
    API --> Controller
    Controller --> Validate
    Validate -->|Valid| Parse
    Validate -->|Invalid| Error[Return Error]
    
    Parse --> StoreData
    Parse --> UpdateMeter
    Parse --> UpdateGateway
    
    StoreData --> Success[Return Success]
    UpdateMeter --> Success
    UpdateGateway --> Success
    
    style Field fill:#fff4e6
    style Transport fill:#e3f2fd
    style Backend fill:#e8f5e9
    style Storage fill:#f3e5f5
    style Error fill:#ffebee
    style Success fill:#c8e6c9
```

### Detailed Step-by-Step

#### Step 1: Meter Polling (Gateway)

**Frequency:** Every 15 minutes  
**Protocol:** Modbus RTU/TCP  
**Location:** Field (gateway device)

```python
# Gateway Python script (simplified)
import pymodbus
import time

while True:
    for meter in meters:
        # Read Modbus registers based on config file
        config = get_config_file(meter.config_id)
        
        for register in config.registers:
            value = modbus_client.read_holding_registers(
                register.address, 
                register.count, 
                unit=meter.modbus_address
            )
            
            parsed_value = parse_value(value, register.data_type) * register.multiplier
            readings[register.name] = parsed_value
        
        # Store readings for CSV generation
        store_reading(meter.id, readings)
    
    time.sleep(900)  # 15 minutes
```

**Data Read:**
- Voltage (L1, L2, L3)
- Current (L1, L2, L3)
- Active Power (kW)
- Reactive Power (kVAr)
- Power Factor
- Active Energy Import (kWh) ‚úÖ Primary metric
- Frequency

#### Step 2: CSV Generation (Gateway)

**Format:** Load Profile CSV  
**Location:** Gateway device

**CSV Structure:**
```csv
Timestamp,Meter_ID,Gateway_MAC,kWh_Import,kWh_Export,kW,kVAr,PF,Voltage_Avg,Current_Avg
2024-03-15 08:00:00,MTR-001,00:11:22:33:44:55,12345.678,0.000,150.5,45.2,0.95,230.5,350.2
2024-03-15 08:15:00,MTR-001,00:11:22:33:44:55,12350.123,0.000,148.3,43.8,0.96,230.2,348.9
```

**File Naming:** `LoadProfile_{MAC}_{YYYYMMDD_HHMMSS}.csv`

#### Step 3: HTTP Upload (Gateway ‚Üí CAMR)

**Endpoint:** `POST /lp/receive_file.php`  
**Method:** HTTP POST (multipart/form-data)  
**Frequency:** Every 15 minutes (after polling)

**Request:**
```http
POST /lp/receive_file.php HTTP/1.1
Host: camr.robinsons-mall.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="LoadProfile_001122334455_20240315_080000.csv"
Content-Type: text/csv

[CSV content]
------WebKitFormBoundary--
```

#### Step 4: Data Validation (Backend)

**Controller:** `LoadProfileController.php`  
**Location:** `app/Http/Controllers/LoadProfileController.php`

**Validation Checks:**
```php
public function LoadProfile(Request $request)
{
    // 1. Validate file upload
    if (!$request->hasFile('file')) {
        return response()->json(['error' => 'No file uploaded'], 400);
    }
    
    // 2. Extract gateway MAC from filename
    $filename = $request->file('file')->getClientOriginalName();
    $mac = extract_mac_from_filename($filename);
    
    // 3. Verify gateway exists
    $gateway = GatewayModel::where('gateway_mac', $mac)->first();
    if (!$gateway) {
        return response()->json(['error' => 'Gateway not found'], 404);
    }
    
    // 4. Parse CSV
    $csv = $request->file('file');
    $data = parse_csv($csv);
    
    // 5. Validate data format
    foreach ($data as $row) {
        if (!validate_row($row)) {
            return response()->json(['error' => 'Invalid data format'], 400);
        }
    }
    
    // Proceed to storage...
}
```

#### Step 5: Data Storage (Backend)

**Tables Updated:**
1. `meter_data` - Time-series readings
2. `meter_details.last_log_update` - Last data timestamp
3. `meter_rtu.last_log_update` - Last gateway communication

**Storage Logic:**
```php
foreach ($data as $row) {
    // Insert time-series data
    DB::table('meter_data')->insert([
        'meter_idx' => $row['meter_id'],
        'timestamp' => $row['timestamp'],
        'kwh_import' => $row['kwh_import'],
        'kwh_export' => $row['kwh_export'],
        'kw' => $row['kw'],
        'kvar' => $row['kvar'],
        'power_factor' => $row['pf'],
        'voltage_avg' => $row['voltage'],
        'current_avg' => $row['current'],
        'created_at' => now()
    ]);
    
    // Update meter last update
    DB::table('meter_details')
        ->where('meter_id', $row['meter_id'])
        ->update(['last_log_update' => $row['timestamp']]);
}

// Update gateway last update
DB::table('meter_rtu')
    ->where('gateway_mac', $mac)
    ->update(['last_log_update' => now()]);

return response()->json(['status' => 'success']);
```

---

## üìä Report Generation Data Flow

### SAP Report Flow

```mermaid
flowchart TB
    User([User Selects<br/>Site + Date Range]) --> Form[Report Form<br/>SAP Report Page]
    Form --> Submit[Submit Request]
    Submit --> Controller[SAPReportController]
    
    Controller --> Query["Query Database<br/>meter_data table"]
    Query --> Aggregate["Aggregate Data<br/>SUM(kWh) per meter"]
    Aggregate --> Calculate["Calculate Deltas<br/>Current - Previous"]
    
    Calculate --> Template[Load Excel Template<br/>SAP_Report.xlsx]
    Template --> Populate["Populate Cells<br/>Meter by meter"]
    Populate --> Format["Apply Formatting<br/>Borders, Numbers"]
    
    Format --> Generate[Generate Excel File]
    Generate --> Download["Stream to Browser<br/>Force Download"]
    Download --> UserFile([User Downloads<br/>Excel File])
    
    style User fill:#e3f2fd
    style UserFile fill:#e3f2fd
    style Query fill:#fff4e6
    style Generate fill:#e8f5e9
```

**Query Example:**
```sql
SELECT 
    m.meter_name,
    m.customer_name,
    -- Current reading
    (SELECT kwh_import FROM meter_data 
     WHERE meter_idx = m.meter_id 
     AND DATE(timestamp) = '2024-03-31' 
     ORDER BY timestamp DESC LIMIT 1) AS current_reading,
    -- Previous reading
    (SELECT kwh_import FROM meter_data 
     WHERE meter_idx = m.meter_id 
     AND DATE(timestamp) = '2024-02-29' 
     ORDER BY timestamp DESC LIMIT 1) AS previous_reading
FROM meter_details m
WHERE m.site_idx = ?
ORDER BY m.meter_name;
```

**Calculation:**
```php
$consumption = $current_reading - $previous_reading;
$amount = $consumption * $rate_per_kwh;
```

---

## üîÑ Configuration Update Data Flow

### Gateway Configuration Update

```mermaid
flowchart TB
    Admin([Admin Enables<br/>CSV Update]) --> UI[Site Details Page<br/>Gateway Tab]
    UI --> AJAX[AJAX Request<br/>enablecsvUpdate]
    AJAX --> Controller[CAMRGatewayController]
    
    Controller --> Update["Update meter_rtu<br/>csv_update_flag = 1"]
    Update --> Response[Return Success]
    Response --> UIUpdate[UI Shows Status<br/>Update Pending]
    
    subgraph Gateway["Gateway Polling"]
        Poll[Gateway Polls Every 5min<br/>rtu_check_update/get_update_csv]
        Check[Check csv_update_flag]
        Download[Download CSV File<br/>get_content_csv]
        Apply[Apply Configuration]
        Reset[Reset Flag<br/>reset_update_csv]
    end
    
    Response -.->|Eventually| Poll
    Poll --> Check
    Check -->|Flag = 1| Download
    Download --> Apply
    Apply --> Reset
    
    style Admin fill:#e3f2fd
    style Gateway fill:#fff4e6
```

**API Endpoints:**
```php
// Check if update available
GET /rtu/index.php/rtu/rtu_check_update/{mac}/get_update_csv
Response: {"update_available": true}

// Download configuration
GET /rtu/index.php/rtu/rtu_check_update/{mac}/get_content_csv
Response: [CSV file content]

// Confirm update applied
GET /rtu/index.php/rtu/rtu_check_update/{mac}/reset_update_csv
Response: {"status": "success"}
```

---

## üîç User Query Data Flow

### Site Dashboard Load

```mermaid
flowchart TB
    User([User Navigates to<br/>Site Details]) --> Auth[Authentication Check<br/>CAMRAuthCheck middleware]
    Auth --> Authz[Authorization Check<br/>user_access_group]
    
    Authz -->|Authorized| Controller[CAMRSiteController<br/>site_details_2]
    Authz -->|Unauthorized| Deny[403 Forbidden]
    
    Controller --> Q1["Query Site Info<br/>meter_site JOIN meter_building"]
    Controller --> Q2["Query Offline Counts<br/>DATEDIFF >= 1"]
    Controller --> Q3["Query Total Counts<br/>Gateway + Meters"]
    
    Q1 --> Combine[Combine Data]
    Q2 --> Combine
    Q3 --> Combine
    
    Combine --> View[Render Blade Template<br/>site_main.blade.php]
    View --> Tabs[Load Tabs<br/>Status, Gateways, Meters]
    Tabs --> DataTables["Initialize DataTables<br/>AJAX endpoints"]
    
    DataTables --> Display[Display Dashboard]
    Display --> UserView([User Views Dashboard])
    
    style User fill:#e3f2fd
    style Deny fill:#ffebee
    style Display fill:#e8f5e9
```

**Lazy Loading Pattern:**
- Initial page load: Only basic site info + counts
- Tab clicks: AJAX request for detailed data (DataTables)
- Benefits: Faster initial load, reduced memory usage

---

## üìà Aggregation Data Flow

### Hourly Consumption Report

```mermaid
flowchart TB
    Request([User Requests<br/>Hourly Report]) --> Params["Parameters:<br/>Site, Meter, Date Range"]
    Params --> Controller[ConsumptionReportController]
    
    Controller --> RawQuery["Query meter_data<br/>15-min intervals"]
    RawQuery --> Group["GROUP BY<br/>DATE, HOUR"]
    Group --> Agg["Aggregate:<br/>SUM(kw * 0.25) AS kwh"]
    
    Agg --> Format[Format Results<br/>Array/Collection]
    Format --> Choice{Output Format}
    
    Choice -->|Web View| Blade[Render Blade<br/>consumption_report.blade.php]
    Choice -->|Excel| Template[Load Excel Template]
    
    Template --> Populate[Populate Cells]
    Populate --> ExcelFile[Generate Excel]
    
    Blade --> Display[Display on Web]
    ExcelFile --> Download[Stream Download]
    
    Display --> UserView([User Views Report])
    Download --> UserFile([User Downloads File])
    
    style Request fill:#e3f2fd
    style RawQuery fill:#fff4e6
    style UserView fill:#e8f5e9
    style UserFile fill:#e8f5e9
```

**Query Logic:**
```sql
SELECT 
    DATE(timestamp) AS report_date,
    HOUR(timestamp) AS report_hour,
    SUM(kw * 0.25) AS hourly_kwh  -- 15min interval * 4 = hourly
FROM meter_data
WHERE meter_idx = ?
  AND timestamp BETWEEN ? AND ?
GROUP BY DATE(timestamp), HOUR(timestamp)
ORDER BY timestamp;
```

---

## üîê Authentication Data Flow

```mermaid
flowchart TB
    User([User Enters<br/>Credentials]) --> LoginForm[Login Form]
    LoginForm --> Submit[POST /login-user]
    Submit --> Controller[CAMRUserAuthController]
    
    Controller --> Validate[Validate Input<br/>username, password]
    Validate --> QueryUser["Query user_tb<br/>WHERE user_name = ?"]
    
    QueryUser --> UserExists{User Found?}
    UserExists -->|No| ErrorUser["Error: User not found"]
    UserExists -->|Yes| CheckHash["Hash::check()<br/>Compare passwords"]
    
    CheckHash --> Match{Match?}
    Match -->|No| ErrorPass["Error: Incorrect password"]
    Match -->|Yes| CreateSession["Session::put('loginID', user_id)"]
    
    CreateSession --> Redirect[Redirect to /site]
    Redirect --> Protected["Protected Route<br/>Middleware: isLoggedIn"]
    
    Protected --> CheckSession{Session Exists?}
    CheckSession -->|No| RedirectLogin[Redirect to /]
    CheckSession -->|Yes| Allow[Allow Access]
    
    Allow --> Dashboard([User Accesses Dashboard])
    
    style User fill:#e3f2fd
    style ErrorUser fill:#ffebee
    style ErrorPass fill:#ffebee
    style Dashboard fill:#e8f5e9
```

**Session Storage:**
- **Driver:** Database (sessions table)
- **Lifetime:** 120 minutes (configurable)
- **Data:** `loginID`, `site_current_tab`, etc.

---

## üìâ Offline Detection Data Flow

```mermaid
flowchart TB
    Cron(["Scheduled Job<br/>(Optional Background)"]) --> Query["Query meter_rtu + meter_details<br/>Check last_log_update"]
    
    Query --> Calculate["Calculate Offline:<br/>DATEDIFF(NOW(), last_log_update) >= 1"]
    
    Calculate --> UpdateCache["Update Cached Counts<br/>(if caching enabled)"]
    
    User([User Views Dashboard]) --> LoadSite[Load Site Details]
    LoadSite --> LiveQuery["Query Offline Counts<br/>Real-time"]
    
    LiveQuery --> Display["Display:<br/>Total Gateways: 32<br/>Offline Gateways: 3"]
    
    Display --> DownloadBtn[User Clicks<br/>Download Offline Report]
    DownloadBtn --> OfflineController[OfflineReportController]
    
    OfflineController --> FilterQuery["Re-query Offline Devices<br/>WITH details"]
    FilterQuery --> Excel[Generate Excel Report]
    Excel --> Download[Stream to Browser]
    
    Download --> UserFile([User Downloads<br/>Offline_Gateway_RG.xlsx])
    
    style Cron fill:#fff4e6
    style User fill:#e3f2fd
    style UserFile fill:#e8f5e9
```

**Offline Threshold:** 24 hours (DATEDIFF >= 1)

---

## üîó Related Documentation

- **[Architecture](architecture.md)** - System structure and components
- **[Technology Stack](technology-stack.md)** - Technologies used
- **[Gateway Device API](api/gateway-device-api.md)** - Gateway communication details
- **[Load Profile API](api/load-profile-api.md)** - Data upload format
- **[Database Schema](database-schema.md)** - Data storage structure
- **[Models](models.md)** - Data access layer

---

**Last Updated:** 2024-03-15  
**Document Version:** 1.0  
**Maintainer:** CAMR Development Team
